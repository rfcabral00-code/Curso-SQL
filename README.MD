# üìä Curso de SQL

Este reposit√≥rio re√∫ne os materiais, exemplos pr√°ticos e exerc√≠cios desenvolvidos ao longo do curso de **SQL**, partindo dos conceitos fundamentais at√© consultas anal√≠ticas mais avan√ßadas, com foco em **an√°lise de dados, m√©tricas e l√≥gica de neg√≥cio**.

---

## üéØ Objetivo do curso

Desenvolver a capacidade de **consultar, organizar, cruzar e analisar dados** em bancos relacionais utilizando SQL, preparando o aluno para desafios reais em:

* An√°lise de dados
* Business Intelligence
* Engenharia / Analytics
* Projetos baseados em dados

---

## üóìÔ∏è Dia 1 ‚Äì Fundamentos de SQL

Introdu√ß√£o aos conceitos b√°sicos e √† estrutura das consultas SQL.

### Conte√∫dos abordados

* Introdu√ß√£o ao SQL e bancos de dados relacionais
* Prepara√ß√£o do ambiente (VS Code)
* Estrutura b√°sica de um script SQL
* Primeiro comando: *Ol√°, mundo em SQL*
* Comandos fundamentais:

  * `SELECT`
  * `FROM`
  * `WHERE`
* Introdu√ß√£o √†s cl√°usulas SQL
* Cria√ß√£o de colunas calculadas
* Exerc√≠cios de fixa√ß√£o

---

## üóìÔ∏è Dia 2 ‚Äì ORDER BY e CASE WHEN

Aula focada em **organiza√ß√£o de resultados** e **l√≥gica condicional**.

### üîπ ORDER BY

Utilizado para ordenar os resultados de uma consulta.

```sql
SELECT *
FROM clientes
WHERE flTwitch = 1
ORDER BY DtCriacao ASC, QtdePontos DESC;
```

---

### üîπ CASE WHEN

Permite criar regras condicionais e novas colunas derivadas.

```sql
SELECT idCliente,
       QtdePontos,
       CASE
            WHEN QtdePontos <= 500 THEN 'Ponei'
            WHEN QtdePontos <= 1000 THEN 'Ponei Premium'
            WHEN QtdePontos <= 5000 THEN 'Mago Aprendiz'
            WHEN QtdePontos <= 10000 THEN 'Mago Mestre'
            ELSE 'Mago Supremo'
       END AS NomeGrupo
FROM clientes;
```

### Exerc√≠cio ‚Äì CASE WHEN

```sql
SELECT *,
       CASE
            WHEN QtdePontos < 10 THEN 'baixo'
            WHEN QtdePontos < 500 THEN 'm√©dio'
            ELSE 'alto'
       END AS Nivel
FROM transacoes;
```

---

## üóìÔ∏è Dia 3 ‚Äì Agrega√ß√µes, DISTINCT e COUNT

Introdu√ß√£o √†s **fun√ß√µes de agrega√ß√£o** e deduplica√ß√£o de dados.

### üîπ COUNT e COUNT DISTINCT

```sql
SELECT
    COUNT(*) AS totalRegistros,
    COUNT(DISTINCT IdTransacao) AS transacoesDistintas,
    COUNT(DISTINCT idCliente) AS clientesDistintos
FROM transacoes
WHERE DtCriacao >= '2025-07-01'
  AND DtCriacao <  '2025-08-01';
```

---

### üîπ SUM com CASE WHEN

```sql
SELECT
    SUM(qtdePontos) AS qtdePontosTotal,
    SUM(CASE WHEN qtdePontos > 0 THEN qtdePontos END) AS qtdePontosPositivos,
    SUM(CASE WHEN qtdePontos < 0 THEN qtdePontos END) AS qtdePontosNegativos,
    COUNT(CASE WHEN qtdePontos < 0 THEN 1 END) AS qtdeTransacoesNegativas
FROM transacoes
WHERE DtCriacao >= '2025-07-01'
  AND DtCriacao <  '2025-08-01';
```

---

### üîπ AVG, MIN, MAX e ROUND

```sql
SELECT
    ROUND(AVG(qtdePontos), 2) AS mediaCarteira,
    ROUND(1.0 * SUM(qtdePontos) / COUNT(idCliente), 2) AS mediaCarteiraRoots,
    MIN(qtdePontos) AS minCarteira,
    MAX(qtdePontos) AS maxCarteira,
    SUM(flTwitch) AS totalTwitch,
    SUM(flEmail) AS totalEmail
FROM clientes;
```

---

## üóìÔ∏è Dias 4, 5 e 6 ‚Äì GROUP BY, HAVING, JOIN, Subqueries e CTEs

Parte central do curso, focada em **SQL anal√≠tico e cruzamento de dados**.

---

## üîπ GROUP BY

Agrupa dados para aplica√ß√£o de m√©tricas por entidade.

```sql
SELECT idCliente,
       SUM(qtdePontos) AS totalPontos,
       COUNT(IdTransacao) AS totalTransacoes
FROM transacoes
WHERE DtCriacao >= '2025-07-01'
  AND DtCriacao <  '2025-08-01'
GROUP BY idCliente
ORDER BY totalPontos DESC
LIMIT 10;
```

---

## üîπ HAVING

Filtra resultados **ap√≥s a agrega√ß√£o**.

```sql
HAVING SUM(qtdePontos) >= 4000
```

---

## üîπ JOIN

Cruzamento de dados entre tabelas relacionadas.

```sql
SELECT t1.*, t2.DescCategoriaProduto
FROM transacao_produto AS t1
LEFT JOIN produtos AS t2
ON t1.IdProduto = t2.IdProduto;
```

---

## üîπ Subqueries

Utiliza√ß√£o de consultas dentro de outras consultas.

```sql
SELECT COUNT(DISTINCT idCliente)
FROM transacoes AS t1
WHERE t1.idCliente IN (
    SELECT DISTINCT idCliente
    FROM transacoes
    WHERE substr(DtCriacao,1,10) = '2025-08-25'
)
AND substr(t1.DtCriacao,1,10) = '2025-08-29';
```

---

## üîπ CTEs (Common Table Expressions)

Forma organizada e leg√≠vel de estruturar consultas complexas.

```sql
WITH tb_cliente_primeiro_dia AS (
    SELECT DISTINCT idCliente
    FROM transacoes
    WHERE substr(DtCriacao,1,10) = '2025-08-25'
),
tb_cliente_ultimo_dia AS (
    SELECT DISTINCT idCliente
    FROM transacoes
    WHERE substr(DtCriacao,1,10) = '2025-08-29'
),
tb_join AS (
    SELECT t1.idCliente AS primCliente,
           t2.idCliente AS ultCliente
    FROM tb_cliente_primeiro_dia AS t1
    LEFT JOIN tb_cliente_ultimo_dia AS t2
    ON t1.idCliente = t2.idCliente
)
SELECT
    COUNT(primCliente) AS clientesInicio,
    COUNT(ultCliente) AS clientesFim,
    1.0 * COUNT(ultCliente) / COUNT(primCliente) AS taxaRetencao
FROM tb_join;
```

---

## üöÄ Pr√≥ximos temas

* Window Functions (`ROW_NUMBER`, `RANK`, `OVER`)
* Enumera√ß√£o e rankings
* An√°lise temporal
* DDL e DML
* Projeto final pr√°tico

---

## ‚úÖ Status

Conte√∫do at√© SQL **n√≠vel intermedi√°rio**, com base s√≥lida para avan√ßar em an√°lises complexas e projetos reais.
